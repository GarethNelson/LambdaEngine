Define dlsym API
  Create a single C module that must be linked to by each shared lib and main executable
  Move symbols into standard header file
  Macro in header file for importing symbols
    Modules include the header file and then do something like IMPORT(video_init) in their own init function
  Put global state in header file
  After all core modules are in place, document the API and refactor
  Change video_pre_render and video_post_render so they run hooks

Hardcoded screen res must go
  Put the screen res into global state at startup
   Fullscreen flag

Isolate SDL into seperate module
  move all SDL-specific code into hooks
    e.g video_init() should run a platform_video_init_glcontext() hook which SDL module registers a callback on
    SDL_PumpEvents() and SDL_GL_SwapWindow() should be moved into video_post_render hook callbacks

module hooks system
  List hooks in dlsym API header file using macro to define function add_hook_whatever and run_hook_whatever
     e.g add_hook_video_pre_render
  Each hook is a function that takes a pointer (void*) as param
    The pointer may be void, otherwise it should be a pointer to a struct typedef defined in the dlsym API header
  Modules may add their own callbacks using add_hook_whatever
  Modules (and main engine core) may run all registered callbacks using run_hook_whatever
  Each hook holds an array of callbacks of a certain max size
  run_hook_whatever() simply iterates through the array until a NULL pointer is found
    therefore order of adding callbacks is important

Properly handle quit
  Close window appropriately
Load screen
  Actually preload stuff
   Spawn thread in stage init and create mutex
   Load requested files into VFS cache in other thread, free mutex once all loaded
   In update function, check thread status by seeing if mutex is free
   Once mutex is free, cleanup and go to next stage
   
VFS cache
  Internal hashtable of VFS filenames mapping to sizes and content
  Global assets
    Files which are never unloaded once in the cache
    Linked list of global assets is stored for checking all globals
  Temp assets
    Files which can be unloaded from the cache at any time
    Linked list of temp assets is stored to make cleanup simpler
  Methods:
    Get file content
     If the file requested is not in the cache, file will be loaded from VFS
    Get file length
    Store in cache (for use by loading screen)
    Mark as global
      Mark a file as a global asset
      Updates linked lists to ensure global assets are not in temp asset list
       Marking a temp asset as global results in removing it from the temp assets list
    Mark as temp
      Mark a file as a temp asset
      Updates linked lists to ensure global assets are not in temp asset list
       Attempting to mark a global asset as temp is a NOP
    Cleanup
      Evicts all temp assets from the cache - useful for map changes

Texture manager
  Methods:
     load texture   - loads texture from VFS cache and sends to the GPU ready for use
     unload texture - unloads the texture from the GPU
     unload all     - unloads all textures from the GPU - should be run between maps and FSM stages
     get texture    - returns the texture ID for a loaded texture by given filename if loaded
                      if not loaded, attempts to load
